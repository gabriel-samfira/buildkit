//go:build windows

// Code generated by 'go generate' using "github.com/Microsoft/go-winio/tools/mkwinsyscall"; DO NOT EDIT.

package winapi

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modoffreg = windows.NewLazySystemDLL("offreg.dll")

	procORCloseHive    = modoffreg.NewProc("ORCloseHive")
	procORCloseKey     = modoffreg.NewProc("ORCloseKey")
	procOREnumKey      = modoffreg.NewProc("OREnumKey")
	procOREnumValue    = modoffreg.NewProc("OREnumValue")
	procOROpenHive     = modoffreg.NewProc("OROpenHive")
	procOROpenKey      = modoffreg.NewProc("OROpenKey")
	procORQueryInfoKey = modoffreg.NewProc("ORQueryInfoKey")
)

func ORCloseHive(key *syscall.Handle) (regerrno error) {
	r0, _, _ := syscall.Syscall(procORCloseHive.Addr(), 1, uintptr(unsafe.Pointer(key)), 0, 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func ORCloseKey(key *syscall.Handle) (regerrno error) {
	r0, _, _ := syscall.Syscall(procORCloseKey.Addr(), 1, uintptr(unsafe.Pointer(key)), 0, 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func OREnumKey(key syscall.Handle, index uint32, name *uint16, nameSize *uint32, class *uint16, classSize *uint32, ftLastWriteTime uintptr) (regerrno error) {
	r0, _, _ := syscall.Syscall9(procOREnumKey.Addr(), 7, uintptr(key), uintptr(index), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameSize)), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classSize)), uintptr(ftLastWriteTime), 0, 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func OREnumValue(key syscall.Handle, index uint32, valueName *uint16, valueNameSize *uint32, valueType *uint32, data *byte, bufferSize *uint32) (regerrno error) {
	r0, _, _ := syscall.Syscall9(procOREnumValue.Addr(), 7, uintptr(key), uintptr(index), uintptr(unsafe.Pointer(valueName)), uintptr(unsafe.Pointer(valueNameSize)), uintptr(unsafe.Pointer(valueType)), uintptr(unsafe.Pointer(data)), uintptr(unsafe.Pointer(bufferSize)), 0, 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func OROpenHive(file *uint16, key *syscall.Handle) (regerrno error) {
	r0, _, _ := syscall.Syscall(procOROpenHive.Addr(), 2, uintptr(unsafe.Pointer(file)), uintptr(unsafe.Pointer(key)), 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func OROpenKey(rootKey syscall.Handle, lpSubKeyName *uint16, key *syscall.Handle) (regerrno error) {
	r0, _, _ := syscall.Syscall(procOROpenKey.Addr(), 3, uintptr(rootKey), uintptr(unsafe.Pointer(lpSubKeyName)), uintptr(unsafe.Pointer(key)))
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func ORQueryInfoKey(key syscall.Handle, lpClass *uint16, lpcClass *uint32, lpcSubKeys *uint32, lpcMaxSubKeyLen *uint32, lpcMaxClassLen *uint32, lpcValues *uint32, lpcMaxValueNameLen *uint32, lpcMaxValueLen *uint32, lpcbSecurityDescriptor *uint32, lpftLastWriteTime uintptr) (regerrno error) {
	r0, _, _ := syscall.Syscall12(procORQueryInfoKey.Addr(), 11, uintptr(key), uintptr(unsafe.Pointer(lpClass)), uintptr(unsafe.Pointer(lpcClass)), uintptr(unsafe.Pointer(lpcSubKeys)), uintptr(unsafe.Pointer(lpcMaxSubKeyLen)), uintptr(unsafe.Pointer(lpcMaxClassLen)), uintptr(unsafe.Pointer(lpcValues)), uintptr(unsafe.Pointer(lpcMaxValueNameLen)), uintptr(unsafe.Pointer(lpcMaxValueLen)), uintptr(unsafe.Pointer(lpcbSecurityDescriptor)), uintptr(lpftLastWriteTime), 0)
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}
